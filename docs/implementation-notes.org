#+TITLE: Implementation notes

* Overview

  #+BEGIN_SRC dot :file images/overview.png :exports results
    digraph overview {

      ////////////////
      // Typography //
      ////////////////

      fontname = "Open Sans";
      node [fontname = "Open Sans", fontsize = 10];
      edge [fontname = "Open Sans", fontsize = 10];

      //////////////////
      // Colorschemes //
      //////////////////

      // Plain black-on-white.

      bgcolor = transparent;
      color = "#333333";
      fontcolor = "#333333";
      node [color = "#333333", fontcolor = "#333333"];
      edge [color = "#333333", fontcolor = "#333333"];

      ///////////////
      // Box style //
      ///////////////

      style = "rounded";
      node [shape = box, style = "rounded"];

      ///////////
      // Graph //
      ///////////

      "Program" -> "Initial constraint set" [label = " 1 · Initial alignment"];

      subgraph cluster_typechecking {
        label = "Typechecking";

        "Initial constraint set" -> "Dependency graph constraint set" [label = " 2 · Ordering constraint closure"];
        "Dependency graph constraint set" -> "Dependency graph" [label = " 3 · Depedency resolution"];
        full_constraint_closure [shape = point, width = 0.01, height = 0.01];
        "Dependency graph" -> full_constraint_closure [dir = none];
        "Initial constraint set" -> full_constraint_closure [dir = none];
        full_constraint_closure -> "Full constraint set" [label = " 4 · Full constraint closure"];
        "5 · Immediately consistent?" [shape = diamond];
        "Full constraint set" -> "5 · Immediately consistent?";
      }

      typechecking_failed [style = invisible];
      "5 · Immediately consistent?" -> typechecking_failed [label = " 6.1 · No · Typechecking failed"];
      "5 · Immediately consistent?" -> "Type dispatch relation" [label = " 6.2 · Yes · Typechecking succeeded\n   7 · Type dispatch relation extraction"];

      "Type dispatch relation" -> "Expression dispatch relation" [label = " 8 · Expression dispatch relation extraction"];
      evaluation [shape = point, width = 0.01, height = 0.01];
      "Expression dispatch relation" -> evaluation [dir = none];
      "Program" -> evaluation [dir = none];
      evaluation -> "Computation result" [label = " 9 · Evaluation"];
    }
  #+END_SRC

  #+RESULTS:
  [[file:images/overview.png]]

* Constraint closures

  - Rules :: Functions that take a constraint set as a parameter and return an
             augmented constraint set with new constraints.

             Don't perform a single step, but the fixpoint (=ω=).

             Return the input constraint set augmented with the new constraints,
             /not/ only the new constraints.

  - Closures :: Functions that compose the action of rules or other
                closures. Respect the same behavior as rules.

  Some rules and closures take additional parameters (e.g. a dependency
  graph). They should be /curried in/ before usage.

** Constraint closure dependency graph

   #+BEGIN_SRC dot :file images/constraint-closure-dependency-graph.png :exports results
     digraph overview {

       ////////////////
       // Typography //
       ////////////////

       fontname = "Open Sans";
       node [fontname = "Open Sans", fontsize = 10];
       edge [fontname = "Open Sans", fontsize = 10];

       //////////////////
       // Colorschemes //
       //////////////////

       // Plain black-on-white.

       bgcolor = transparent;
       color = "#333333";
       fontcolor = "#333333";
       node [color = "#333333", fontcolor = "#333333"];
       edge [color = "#333333", fontcolor = "#333333"];

       ///////////////
       // Box style //
       ///////////////

       style = "rounded";
       node [shape = box, style = "rounded"];

       ///////////
       // Graph //
       ///////////

       subgraph cluster_legend {
         label = "Legend";

         "A" -> "B" [label = " uses"];
       }

       "Ordering constraint closure" -> "Non-function constraint closure";
       "Ordering constraint closure" -> "Ordering-function constraint closure";

       "Full constraint closure" -> "Non-function constraint closure";
       "Full constraint closure" -> "Function constraint closure";
     }
   #+END_SRC

   #+RESULTS:
   [[file:images/constraint-closure-dependency-graph.png]]

   Leaves are based directly on rules.
