#+TITLE: Implementation notes

* Overview

  #+BEGIN_SRC dot :file images/overview.png :exports results
    digraph overview {
      fontname = "Open Sans";
      color = "#333333";
      fontcolor = "#333333";
      node [fontname = "Open Sans", fontsize = 10, shape = box, style = "rounded", color = "#333333", fontcolor = "#333333"];
      edge [fontname = "Open Sans", fontsize = 10, color = "#333333", fontcolor = "#333333"];

      "Program" -> "Initial constraint set" [label = " 1 · Initial alignment"];

      subgraph cluster_typechecking {
        label = "Typechecking";
        style = "rounded";

        "Initial constraint set" -> "Dependency graph constraint set" [label = " 2 · Ordering constraint closure"];
        "Dependency graph constraint set" -> "Dependency graph" [label = " 3 · Depedency resolution"];
        full_constraint_closure [shape = point, width = 0.01, height = 0.01];
        "Dependency graph" -> full_constraint_closure [dir = none];
        "Initial constraint set" -> full_constraint_closure [dir = none];
        full_constraint_closure -> "Full constraint set" [label = " 4 · Full constraint closure"];
        "5 · Immediately consistent?" [shape = diamond];
        "Full constraint set" -> "5 · Immediately consistent?";
      }

      typechecking_failed [style = invisible];
      "5 · Immediately consistent?" -> typechecking_failed [label = " 6.1 · No · Typechecking failed", lhead = cluster_typechecking];
      "5 · Immediately consistent?" -> "Type dispatch relation" [label = " 6.2 · Yes · Typechecking succeeded\n   7 · Type dispatch relation extraction"];

      "Type dispatch relation" -> "Expression dispatch relation" [label = " 8 · Expression dispatch relation extraction"];
      evaluation [shape = point, width = 0.01, height = 0.01];
      "Expression dispatch relation" -> evaluation [dir = none];
      "Program" -> evaluation [dir = none];
      evaluation -> "Computation result" [label = " 9 · Evaluation"];
    }
  #+END_SRC

  #+RESULTS:
  [[file:images/overview.png]]

* Constraint closures

  - Rules :: Functions that take a constraint set as a parameter and return an
             augmented constraint set with new constraints.

             Don't perform a single step, but the fixpoint (=ω=).

             Return the input constraint set augmented with the new constraints,
             /not/ only the new constraints.

  - Closures :: Functions that compose the action of rules or other
                closures. Respect the same behavior as rules.

  Some rules and closures take additional parameters (e.g. a dependency
  graph). They should be /curried in/ before usage.

  #+BEGIN_SRC plantuml :file images/constraint-closure-dependency-graph.png :exports results
    title Constraint closure dependency graph

    "A" ->[uses] "B"

    "Ordering constraint closure" --> "Non-function constraint closure"
    "Ordering constraint closure" --> "Ordering-function constraint closure"

    "Full constraint closure" --> "Non-function constraint closure"
    "Full constraint closure" --> "Function constraint closure"

    note bottom: Leaves are based directly on rules
  #+END_SRC

  #+RESULTS:
  [[file:images/constraint-closure-dependency-graph.png]]
