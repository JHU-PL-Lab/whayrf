#+TITLE: Implementation notes

* Overview

  #+BEGIN_SRC plantuml :file images/overview.png :exports results
    title Overview

    "Program" --> ===evaluation===

    partition Typechecking {
      "Program" -->[1 · Initial alignment] "Initial constraint set"
      "Initial constraint set" -->[2 · Ordering constraint closure] "Dependency graph constraint set"
      -->[3 · Depedency resolution] "Dependency graph"
      --> ===full_constraint_closure===
      "Initial constraint set" --> ===full_constraint_closure===
      ===full_constraint_closure=== -->[4 · Full constraint closure] "Full constraint set"
      if "5 · Immediately consistent?" then
        -->[6.1 · No · Typechecking failed] ===typechecking_failed===
      else
        -->[6.2 · Yes · Typechecking succeeded] ===typechecking_succeeded===
      endif
    }

    ===typechecking_failed=== --> (*)
    ===typechecking_succeeded=== -->[7 · Type dispatch relation extraction] "Type dispatch relation"

    "Type dispatch relation" -->[8 · Expression dispatch relation extraction] "Expression dispatch relation"
    --> ===evaluation===
    -->[9 · Evaluation] "Computation result"
  #+END_SRC

  #+RESULTS:
  [[file:images/overview.png]]

* Constraint closures

  - Rules :: Functions that take a constraint set as a parameter and return an
             augmented constraint set with new constraints.

             Don't perform a single step, but the fixpoint (=ω=).

             Return the input constraint set augmented with the new constraints,
             /not/ only the new constraints.

  - Closures :: Functions that compose the action of rules or other
                closures. Respect the same behavior as rules.

  Some rules and closures take additional parameters (e.g. a dependency
  graph). They should be /curried in/ before usage.

  #+BEGIN_SRC plantuml :file images/constraint-closure-dependency-graph.png :exports results
    title Constraint closure dependency graph

    "A" ->[uses] "B"

    "Ordering constraint closure" --> "Non-function constraint closure"
    "Ordering constraint closure" --> "Ordering-function constraint closure"

    "Full constraint closure" --> "Non-function constraint closure"
    "Full constraint closure" --> "Function constraint closure"

    note bottom: Leaves are based directly on rules
  #+END_SRC

  #+RESULTS:
  [[file:images/constraint-closure-dependency-graph.png]]
