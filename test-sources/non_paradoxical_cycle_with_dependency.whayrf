# EXPECT-TYPEFAIL

# This captures the essence of the following snippet which is a variation on
# the one from the overview section
# of the paper:
#
# let rec cycle n:int =
#   let identity = fun parameter -> parameter in
#   let scrubbles = case identity of
#                   {} ~> {} -> fun parameter -> parameter
#   in
#   case scrubbles cycle of
#   int ~> {} -> 0
#   _ -> 0
# in cycle 4
#
# The cycle is stable only on the `anti-match' condition, but we default to
# `match' when cycle breaking, so typechecking fails.
#
# This differs from `tautology_simple.wharf' because `tautology_simple.wharf'
# stable on the `match' condition.
#
# The purpose of this test is to guarantee that a function_type-pattern pair can
# point to itself as a dependency.

yCombinator = fun fYCombinator -> {

  yCombinatorFunction = fun xYCombinatorFunction -> {
    argumentYCombinatorFunction = fun vArgumentYCombinatorFunction -> {
      functionArgumentYCombinatorFunction = xYCombinatorFunction xYCombinatorFunction;
      returnArgumentYCombinatorFunction = functionArgumentYCombinatorFunction vArgumentYCombinatorFunction;
    };
    returnYCombinatorFunction = fYCombinator argumentYCombinatorFunction;
  };

  yCombinatorParameter = fun xYCombinatorParameter -> {
    argumentYCombinatorParameter = fun vArgumentYCombinatorParameter -> {
      functionArgumentYCombinatorParameter = xYCombinatorParameter xYCombinatorParameter;
      returnArgumentYCombinatorParameter = functionArgumentYCombinatorParameter vArgumentYCombinatorParameter;
    };
    returnYCombinatorParameter = fYCombinator argumentYCombinatorParameter;
  };

  returnYCombinator = yCombinatorFunction yCombinatorParameter;
};

partialCycle = fun recursePartialCycle -> {
  returnRecursePartialCycle = fun n -> {
    identity = fun identityParameter -> {
      returnIdentity = identityParameter;
    };
    scrubbles = identity
      ~ fun {} ~> {{}} ?
      scubblesMatch -> {
        otherIdentity = fun otherIdentityParameter -> {
          returnOtherIdentity = otherIdentityParameter;
        };
      } : scrubblesAntimatch -> {
        bogusFunctionPartialParadoxAntimatchAntimatch = {};
        parameterForBogusFunctionPartialParadoxAntimatchAntimatch = {};
        returnPartialParadoxAntimatchAntimatch = bogusFunctionPartialParadoxAntimatchAntimatch parameterForBogusFunctionPartialParadoxAntimatchAntimatch
      };
    subject = scrubbles recursePartialCycle;
    returnPartialCycle = subject ~ fun { int: {} } ~> { { notInt: {} } } ?
      partialCycleMatch -> {
        intForPartialCycleMatch = {};
        returnPartialCycleMatch = { int = intForPartialCycleMatch }
      } : partialCycleAntimatch -> {
        notIntForPartialCycleMatch = {};
        returnPartialCycleAntimatchMatch = { int = notIntForPartialCycleMatch }
      }
  };
};

cycle = yCombinator partialCycle;

intForCycle = {};
parameterForCycle = { int = intForCycle };

return = cycle parameterForCycle;
