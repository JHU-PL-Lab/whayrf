open Batteries;;

open Whayrf_ast;;
open Whayrf_ast_pretty;;
open Whayrf_consistency;;
open Whayrf_constraint_closure_non_function;;
open Whayrf_function_pattern_search;;
open Whayrf_initial_alignment;;
open Whayrf_logger;;
open Whayrf_notation;;
open Whayrf_pattern_subsumption;;
open Whayrf_type_compatibility;;
open Whayrf_types;;
open Whayrf_types_pretty;;
open Whayrf_utils;;

let logger = make_logger "Whayrf_constraint_closure_function";;

(** Perform Function Constraint Closure (i.e. the one with the F superscript).

    This function doesn't perform a single step, but the fixpoint (omega). This
    returns the augmented constraint set with the new constraints as well as the
    original constraints. *)
let perform_function_closure perform_closure constraint_set =
  let augmented_constraint_set =
    constraint_set
    |> Constraint_set.enum
    |> Enum.filter_map
      (
        fun tconstraint ->
          match tconstraint with
          (* FUNCTION CLOSURE *)
          | Lower_bound_constraint (
              Conditional_lower_bound (
                type_variable,
                pattern,
                _,
                _
              ),
              _
            )

          (* FUNCTION CLOSURE (UPPER BOUNDING PATTERN) *)
          | Type_variable_constraint (
              type_variable,
              pattern
            ) ->
            Some (function_pattern_search_type_variable perform_closure type_variable constraint_set pattern)
          | _ -> None
      )
    |> Enum.fold Constraint_set.union constraint_set
  in
  logger `trace ("New constraints generated by function constraint closure: `" ^ pretty_constraint_set (Constraint_set.diff augmented_constraint_set constraint_set) ^ "'.");
  augmented_constraint_set
;;
