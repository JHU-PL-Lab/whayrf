open Batteries;;

open Whayrf_ast;;
open Whayrf_ast_pretty;;
open Whayrf_consistency;;
open Whayrf_constraint_closure_non_function;;
open Whayrf_function_pattern_search;;
open Whayrf_initial_alignment;;
open Whayrf_logger;;
open Whayrf_notation;;
open Whayrf_pattern_subsumption;;
open Whayrf_type_compatibility;;
open Whayrf_types;;
open Whayrf_types_pretty;;
open Whayrf_utils;;

let logger = make_logger "Whayrf_constraint_closure_function";;

type function_pattern_match =
  | Function_pattern_match of function_type * pattern
;;

module Function_pattern_match_order =
struct
  type t = function_pattern_match
  let compare = compare
end;;

module Function_pattern_match_set = Set.Make(Function_pattern_match_order);;

(** FUN PATS

    Find function type-pattern pairs in the constraint set. *)
let find_function_patterns constraint_set =
  constraint_set
  |> Constraint_set.enum
  |> Enum.filter_map
    (
      fun tconstraint ->
        match tconstraint with
        | Lower_bound_constraint (
            Restricted_type_lower_bound (
              Restricted_type (
                Function_type_type (
                  function_type
                ),
                _
              )
            ),
            type_variable
          ) ->
          Some (
            constraint_set
            |> Constraint_set.enum
            |> Enum.filter_map
              (
                fun tconstraint ->
                  match tconstraint with

                  (* S_f *)
                  | Type_variable_constraint (
                      other_type_variable,
                      (
                        Function_pattern (
                        _,
                        _
                        ) as pattern
                      )
                    )

                  (* S_p *)
                  | Lower_bound_constraint (
                      Conditional_lower_bound (
                        other_type_variable,
                        (
                          Function_pattern (
                            _,
                            _
                          ) as pattern
                        ),
                        _,
                        _
                      ),
                      _
                    ) ->
                    if type_variable = other_type_variable then
                      Some (
                        Function_pattern_match (
                          function_type,
                          pattern
                        )
                      )
                    else
                      None

                  | _ -> None
              )
          )
        | _ -> None
    )
  |> Enum.concat
  |> Function_pattern_match_set.of_enum
;;

(** Perform Function Constraint Closure (i.e. the one with the F superscript).

    This function doesn't perform a single step, but the fixpoint (omega). This
    returns the augmented constraint set with the new constraints as well as the
    original constraints. *)
let perform_function_closure perform_closure constraint_set =
  let augmented_constraint_set =
    constraint_set
    |> Constraint_set.enum
    |> Enum.filter_map
      (
        fun tconstraint ->
          match tconstraint with
          (* FUNCTION CLOSURE *)
          | Lower_bound_constraint (
              Conditional_lower_bound (
                type_variable,
                pattern,
                _,
                _
              ),
              _
            )

          (* FUNCTION CLOSURE (UPPER BOUNDING PATTERN) *)
          | Type_variable_constraint (
              type_variable,
              pattern
            ) ->
            Some (function_pattern_search_type_variable perform_closure type_variable constraint_set pattern)
          | _ -> None
      )
    |> Enum.fold Constraint_set.union constraint_set
  in
  logger `trace ("New constraints generated by function constraint closure: `" ^ pretty_constraint_set (Constraint_set.diff augmented_constraint_set constraint_set) ^ "'.");
  augmented_constraint_set
;;
